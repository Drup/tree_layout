<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Layered (tree_layout.Tree_layout__.Layered)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">tree_layout</a> &#x00BB; <a href="../index.html">Tree_layout__</a> &#x00BB; Layered</nav><h1>Module <code>Tree_layout__.Layered</code></h1><nav class="toc"><ul><li><a href="#functorized-api">Functorized API</a></li></ul></nav></header><aside><p>Layered trees</p><p>A layered tree is a tree that is organized by layers: the horizontal position of a node is fixed depending on its depth in the tree, regardless of its height.</p> <a href="https://drup.github.io/tree_layout/layered_tree.svg"><img style="margin : 0 auto; display: block; max-width:90%" src="https://drup.github.io/tree_layout/layered_tree.svg" /></a> <pre><code class="ml">(* Given a nice tree, ... *)
let tree : Tree.t = ...

(* and a distance function. *)
let distance v1 v2 = ...

(* Get positions ! *)
let positions =
  Tree_layout.Layered.layout
    ~children:Tree.children
    ~distance
    tree</code></pre></aside><dl><dt class="spec value" id="val-layout"><a href="#val-layout" class="anchor"></a><code><span class="keyword">val</span> layout : ?&#8288;m:(<span class="keyword">module</span> Stdlib.Hashtbl.HashedType <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>) <span>&#45;&gt;</span> children:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> array) <span>&#45;&gt;</span> distance:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> float) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../Tree_layout/Common/index.html#type-pos">Tree_layout.Common.pos</a></code></dt><dd><p><code>layout ~children ~distance g v</code> returns the layered layout for the tree <code>g</code> rooted in <code>v</code>. Layered layout are such that vertices with the same depth have the same vertical coordinate. The layout is returned as a lookup functions from trees to positions.</p><p>This algorithm is in linear time if <code>children</code> is constant time. Use <a href="Make/index.html"><code>Make</code></a> for a more flexible implementation.</p><p><code>distance v1 v2</code> should return the horizontal distance between <code>v1</code> and <code>v2</code> placed at the same depth.</p><dl><dt>parameter m</dt><dd><p>An hashing specification for the tree type. If not provided, polymorphic comparison and hashing are used.</p></dd></dl><dl><dt>parameter children</dt><dd><p>Return all the subtrees of a tree.</p></dd></dl><dl><dt>see <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.16.8757">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.16.8757</a></dt><dd><p>Improving Walker's Algorithm to Run in Linear Time</p></dd></dl></dd></dl><section><header><h2 id="functorized-api"><a href="#functorized-api" class="anchor"></a>Functorized API</h2></header><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The output signature for the layered layout engine.</p></dd></dl><dl><dt class="spec module-type" id="module-type-TREE"><a href="#module-type-TREE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-TREE/index.html">TREE</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The input signature for <a href="Make/index.html"><code>Make</code></a></p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-G/index.html">G</a> : <a href="index.html#module-type-TREE">TREE</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-t">t</a> := <a href="Make/argument-1-G/index.html#type-t">G.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make/index.html#type-vertex">vertex</a> := <a href="Make/argument-1-G/index.html#module-V">G.V</a>.t</code></dt><dd><p>Full implementation. If the operations in <a href="module-type-TREE/index.html"><code>TREE</code></a> are O(1), the layout functions is O(n).</p></dd></dl></section></div></body></html>